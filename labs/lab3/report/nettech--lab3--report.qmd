---
## Author
author:
  name: Ибрахим Мохсейн Алькамаль
  degrees: Student (3 курс)
  orcid: ""
  email: 1032225432@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчёт по лабораторной работе №3"
subtitle: "Дисциплина: Сетевые технологии"
license: "CC BY"
---

# Цель работы

Изучение посредством Wireshark кадров Ethernet, анализ PDU протоколов транспортного и прикладного уровней стека TCP/IP.

# Выполнение лабораторной работы

## MAC-адресация

С помощью команды ipconfig для ОС типа Windows выводим информацию о текущем сетевом соединении. Просматриваем информацию о сетевых адаптерах и конкретно о беспроводном соединении. Отсюда можно узнать IPv6-адрес, IPv4-адрес (уникальный IPv4-адрес узла), маску подсети (используется для определения сетевой и узловой частей IPv4-адреса) и шлюз (рис. [-@fig:1]).

![Команда ipconfig](image/1.png){#fig:1 width=70%}

Вводим ipconfig /all для вывода более подробной информации. Просматриваем данные о беспроводном соединении. Видим описание устройства (производитель Intel, MAC-адрес - DC-45-46-63-D4-E5). MAC-адрес состоит из 6 октетов:  первые 3 октета идентифицируют производителя, последние 3 октета идентифицируют сетевой интерфейс (рис. [-@fig:2]).

![Команда ipconfig /all](image/2.png){#fig:2 width=70%}

Проверив на специальном сайте производителя устройства по первым 3 октетам выясняем, что устройство выпущено компанией Intel Corporate. Взяв первый байт (DC) и переведя в двоичную систему счисления, получаем 11011100. Так как последний бит = 0, адрес является индивидуальным. Предпоследний бит = 0, следовательно, адрес глобально администрируемый.

##  Анализ кадров канального уровня в Wireshark

Запускаем Wireshark и выбираем беспроводное соединение. Запускаем захват трафика (рис. [-@fig:3]). 

![Запуск захвата трафика](image/3.png){#fig:3 width=70%}

Шлюз по умолчанию для моего устройства - 172.16.36.1 (было определено в предыдущем задании). С помощью команды ping 172.16.36.1  пингуем шлюз по умолчанию (рис. [-@fig:4]). 

![Пинг шлюза по умолчанию](image/4.png){#fig:4 width=70%}

Останавливаем захват трафика. В строке фильтра указываем icmp. Убедимся, что в списке пакетов отобразятся только пакеты ICMP, в частности пакеты, которые были сгенерированы с помощью команды ping, отправленной с моего устройства на шлюз по умолчанию. Видим 4 пакета-запроса и 4 пакета-ответа. Выбираем запрос и просматриваем в нижней части экрана информацию о нем. На вкладке физического уровня можно найти длину кадра (74 бита). Чтобы узнать MAC-адрес источника и шлюза перейдем на канальный уровень. Адрес источника (Source, откуда запрос отправлен) – это адрес моего устройства (DC-46-28-6C-92-D3). Адрес шлюза (destination, то куда отправлен запрос) - 70-18-A7-60-9C-D2. Тип адреса тут указан (показаны нулевые и первые биты MAC-адресов). Что адрес источника, что адрес шлюза индивидуальные и глобально администрируемые (рис. [-@fig:5])

![Кадр ICMP - эхо-запрос: информация о длине кадра, типе Ethernet и MAC-адресах](image/5.png){#fig:5 width=70%}

Далее посмотрим на полученный ответ. Тут все почти то же самое, что и в запросе (длина кадра 74 бита). Только теперь MAC-адрес источника – MAC-адрес шлюза 70-18-A7-60-9C-D2, а адрес назначения – адрес моего устройства (DC-46-28-6C-92-D3) (рис. [-@fig:6]). 

![Кадр ICMP - эхо-ответ: информация о длине кадра, типе Ethernet, MAC-адресах](image/6.png){#fig:6 width=80%}

Изучим кадры данных протокола ARP. ARP-сообщение передаётся в кадре Ethernet II, общая длина кадра составляет 60 байт, включая служебное дополнение (padding).
Поле Hardware type указывает на тип канального протокола — Ethernet (1), Protocol type — на протокол сетевого уровня IPv4. Размер MAC-адреса равен 6 байт, размер IPv4-адреса — 4 байта. Код операции равен 1, что соответствует ARP-запросу. В заголовке Ethernet II указаны MAC-адреса источника и получателя. Адрес получателя — широковещательный (ff:ff:ff:ff:ff:ff). Адрес источника — индивидуальный, глобально администрируемый MAC-адрес сетевого интерфейса отправителя. (индивидуальный и глобально администрируемый) (рис. [-@fig:7]). 

![Кадр ARP: информация о длине кадра, типе Ethernet, MAC-адресах](image/7.png){#fig:7 width=80%}

Начинаем процесс захвата трафика в Wireshark. В командной строке выполняем команду ping rudn.ru.
В результате все ICMP-запросы завершаются по тайм-ауту: отправлено 4 пакета, получено 0, потери составляют 100%. Это указывает на отсутствие ICMP-ответов от узла rudn.ru при данном сетевом подключении (рис. [-@fig:8]).

![Пинг сайта ping rudn.ru](image/8.png){#fig:8 width=80%}

Изучим запрос протокола ICMP (Echo Request). В заголовке Ethernet II адрес источника соответствует MAC-адресу сетевого интерфейса моего устройства — DC-46-28-6C-92-D3. Адрес назначения — MAC-адрес шлюза (следующего узла) — 70-18-A7-60-9C-D2. Оба MAC-адреса являются индивидуальными (unicast) и глобально администрируемыми (factory default) (рис. [-@fig:9]). 

![Запрос протокола ICMP](image/9.png){#fig:9 width=80%}

Также был проанализирован трафик протокола ICMP. В ходе захвата были зафиксированы только ICMP-запросы типа Echo Request. ICMP-ответы типа Echo Reply в захваченном трафике отсутствуют.
Это означает, что удалённый узел не отвечает на ICMP-запросы, либо ICMP-ответы блокируются на одном из сетевых устройств (маршрутизатором, межсетевым экраном или политиками безопасности сети). В результате обмен ICMP-сообщениями является односторонним (рис. [-@fig:10]).

![протокола ICMP](image/10.png){#fig:10 width=80%}



## Анализ протоколов транспортного уровня в Wireshark

Запустив Wireshark, начинаем захват трафика. В браузере открываем сайт, работающий по протоколу HTTP (http://info.cern.ch/), и переходим по страницам сайта. В строке фильтра указываем http и анализируем HTTP-запросы, передаваемые поверх протокола TCP. В TCP-заголовке видно, что порт источника является динамическим и равен 64048, а порт назначения равен 80 — стандартному порту протокола HTTP. Также в заголовке TCP присутствуют поля порядкового номера (Sequence Number) и номера подтверждения (Acknowledgment Number), которые используются для обеспечения надёжной доставки данных(Acknowledgment Number) (рис. [-@fig:11])

![Кадр http - запрос](image/11.png){#fig:11 width=70%}

В случае ответа порты заданы наоборот, то есть источник - 80 порт, назначение - 64048 (рис. [-@fig:12])

![Кадр http - ответ](image/12.png){#fig:12 width=70%}

В Wireshark в строке фильтра укажем dns и проанализируем обмен данными по протоколу UDP при выполнении DNS-запросов и ответов.
При отправке DNS-запроса порт источника является динамическим (случайным) , а порт назначения равен 53 — стандартному порту службы DNS. В ответном DNS-сообщении порт источника равен 53, а порт назначения — динамическому порту клиента 64317 рис. ([-@fig:13]).

![Кадр dns - запрос](image/13.png){#fig:13 width=70%}


В строке фильтра Wireshark укажем quic. Изначально QUIC-трафик не фиксировался, поэтому был использован браузер Google Chrome, после чего соответствующие пакеты появились. Проанализируем работу протокола QUIC. Как и в случае с DNS, можно рассмотреть информацию транспортного уровня, так как QUIC использует протокол UDP. Порт источника является динамическим (непривилегированным) и равен 49768, порт назначения — 443, стандартный порт HTTPS. Протокол QUIC изначально использует шифрование (TLS 1.3), встроенное в сам протокол, что обеспечивает защищённую передачу данных. В ответных пакетах номера портов меняются местами(рис. [-@fig:15]).

![Кадр quic - запрос](image/15.png){#fig:15 width=70%}

## Анализ handshake протокола TCP в Wireshark

Начав захват трафика, запускаем в браузере сайт, работающий по протоколу HTTP (http://info.cern.ch/), однако анализировать будем тот handshake, который нашли для примера. Установление связи клиент-сервер в TCP осуществляется в три этапа (трёхступенчатый handshake).

1. Режим активного доступа (Active Open). Клиент посылает сообщение SYN, ISSa, т.е. в передаваемом сообщении установлен бит SYN (Synchronize Sequence Number), а в поле Порядковый номер (Sequence Number) — начальное 32-битное значение ISSa (Initial Sequence Number)

Находим кадр с флагом SYN. Sequence Number = 0 (рис. [-@fig:16]).

![Первая ступень handshake TCP](image/16.png){#fig:16 width=70%}

2. Режим пассивного доступа (Passive Open). Сервер откликается, посылая сообщение SYN, ACK, ISSb, ACK(ISSa+1), т.е. установлены биты SYN и ACK; в поле Порядковый номер (Sequence Number) хостом B устанавливается начальное значение счётчика — ISSb; поле Номер подтверждения (Acknowledgment Number) содержит значение ISSa, полученное в первом пакете от хоста A и увеличенное на единицу. 

Кадр с флагами SYN и ACK, где ACK равен Sequence Number из предыдущего шага, увеличенный на 1 (0 + 1 = 1) (рис. [-@fig:17]).

![Вторая ступень handshake TCP](image/17.png){#fig:17 width=70%}

3. Завершение рукопожатия. Клиент отправляет подтверждение получения SYNсегмента от сервера с идентификатором, равным ISN (сервера)+1: ACK, ISSa+1, ACK(ISSb+1). В этом пакете установлен бит ACK, поле Порядковый номер (Sequence Number) содержит ISSa+1, поле Номер подтверждения (Acknowledgment Number) содержит значение ISSb+1. Посылкой этого пакета заканчивается трёхступенчатый handshake, и TCP-соединение считается установленным. 

Теперь клиент может посылать пакеты с данными на сервер по только что
созданному виртуальному TCP-каналу: ACK, ISSa+1, ACK(ISSb+1); DATA.

Кадр с флагом ACK, где Sequence Number равен  6231, Acknowledgment Number равен 3590 (рис. [-@fig:18]).

![Третья ступень handshake TCP](image/18.png){#fig:18 width=70%}

В Wireshark в меню «Статистика» выбираем пункт «График потока». На графике видно, что сначала клиент отправляет серверу TCP-сегмент с флагом SYN и относительным номером последовательности Seq = 0. Затем сервер отвечает сегментом с флагами SYN и ACK, при этом Seq = 0, а Ack = 1, что подтверждает получение SYN от клиента. В третьем пакете клиент отправляет сегмент с установленным флагом ACK, где значения Seq = 1 и Ack = 1. Отправка этого пакета завершает процедуру трёхступенчатого TCP-рукопожатия (рис. [-@fig:19]).

![График потока](image/19.png){#fig:19 width=70%}

В Wireshark останавливаем захват трафика. 

# Выводы

В результате выполнения работы были изучены посредством Wireshark кадры Ethernet, произведен анализ PDU протоколов транспортного и прикладного уровней стека TCP/IP.